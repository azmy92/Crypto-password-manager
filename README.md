Crypto-password-manager
=======================

A Javax/crypto password manager which stores the passwords for every domain the user wishes to.

Implementation
--------------
Assumptions
-------------

 - Maximum password length : 16
 - Minimum password length : 7
 
System Architecture
--------------------
The system is composed of three main classes

 **1-PasswordManager.java**
 
contains key functionality:

 - addPassword
 - modifiPassword
 - DeletePassword
 
**2- Cryptographer.java**

 - responsible for
 - ncryption and Decryption
 - creating Tags (Hashing)
 
**3- PasswordMap.java**
 
responsible for
 - maintaining Domain/Password table
 - Handling Authentication
 
The **Singleton** design pattern is used to force one point entry to the system, upon starting the server, the user must provide a master password to be able to view the saved passwords.
                

**Handling Durability**
------------------------

Password table is flushed to the file **"passmap.ser"** which is loaded on start, also the master password hash is saved permanently in "masterPassHash".

**The Serialization** design pattern is used to maintain system durability

Handling Confidentiality
-----------------------
All data saved locally are encrypted using the discussed encryption/Authentication algorithms

Main problems and challenges
-----------------------------

 1 - Understanding the Javax Crypto's API
 
 2 - Handling Crypto's encryption data type, which is a byte array that must be decoded using binary64 formats, this introduces problems regarding saving and retrieving these values.

**Solution:** 
we stored these values in the hexadecimal string format

Block cipher
------------
AES has a fixed block size of 128 bits, and a key size of 128, 192, or 256 bits.
For every given password in the part of Encryption/Decryption we do the following:

###**Encryption/ Decryption**

Initializing a Random Key of length 16

Initializing a Random IV of length 16

Initializing a block cipher giving it the past initialized vectors as a parameters.

So every time we encrypt or decrypt we do that with new vectors to avoid repeating of keys and IVs.

GCM
----
###**Inputs and Outputs**

GCM has two operations, authenticated encryption and authenticated decryption. The authenticated encryption operation has three inputs, each of which is a bit string:

**A secret key K**, whose length is appropriate for the underlying block cipher.
An initialization vector IV that can have any number of bits between 1 and 264. For a fixed value of the key, each IV value must be distinct, so we generated randomly every time 128-bit IV values can be processed more efficiently, so that length used is 128-bit.

**A plaintext P**, which can have any number of bits between 0 and − 256.
There are two outputs: A cipher text C whose length is exactly that of the plaintext P.

**An authentication tag T**, whose length can be any value between 0 and 128. The length of the tag is denoted as t.

MAC (Message Authentication Code)
---------------------------------

An attacker should not be able to modify the content of a message without being detected. This is important to protect against forgery. To achieve integrity a tag will be appended to the message this tag is called Message Authentication Code (MAC).
We would like this tag to work as a signature to provide authenticity to message, which means you can verify that the message is actually sent from the actual sender and that the message was not altered.
The authenticated decryption operation has five inputs: K, IV, C, A, and T. It has only a single output, either the plaintext value P or a special symbol FAIL that indicates that the inputs are not authentic. A cipher text C, initialization vector IV, additional authenticated data A and tag T are authentic for key K when they are generated by the encrypt operation with inputs K, IV, A and P, for some plaintext P. The authenticated decrypt operation will, with high probability, return FAIL whenever its inputs were not created by the encrypt operation with the identical key.

###Padding

We do not need to keep such information can be known by the attacker, so attacker can be able to differentiate between the messages by just length as a signature, so we do padding for messages to keep them all have the same length.
In our implementation we made the maximum size of password is 16-byte, so the if the password is less than that, we do the padding for the rest part to make it of length 16-byte so attacker will fail to differentiate between messages by length.

User Manual
-------------
Initiating the manager by giving the master password to it which is “1234” by calling this line the main method of PasswordManager.java

>>PasswordManager pasman = new PasswordManager("1234");

User Enters Master Password, then authentication happened on this password, in case of success the program passes him to the main program which is the following user abilities.

User has the ability to: **Add – Modify – Delete**

**In case of fail**, then an exception is thrown to show that the master password entered is wrong.

So in case of:

###** ADD Password**

User simply enters the domain and password and then we take the password to encryption process as illustrated above how it works, after that the password is saved with the given domain name.

Just by calling

>>pasman.addPassword("yahoo", "12345");

###Modify Password
User simply enters the domain and password and then we take the password to encryption process, after that the password is verified with the saved password, then user enter the new password to be saved domain name.
Just by calling

>>pasman.modifyPassword("yahoo", "12345");

###Delete Password
User simply enters the domain and password and then we take the password to encryption process, after that the password is verified with the saved password, then the password deleted with the given domain from the system.
Just by calling
>>pasman.deletePassword("yahoo");

###Print Password
You can print the current password of any domain just by giving the domain to >>method getPass(“domain”)


Use Cases
----------
Here is some of the use cases (output) of the program, as for entering given domain and retrieving the corresponding password.
###Here is adding passwords

>>>Adding pair: yahoo, pass:12345
Adding password : google, pass:5441944

Here we modify password of “google” from 5441944 to 5115
Modifying password for google.com is : 5115
In case of deleting passwords, we remove the passwords from the system totally, so if the user tried to retrieve it, we through a message exception to user to inform that the password is not exist anymore
